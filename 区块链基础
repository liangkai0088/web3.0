1.区块链基础
区块链简介
狭义：链式数据结构 通过时间顺序链接 通过密码学 不可篡改 不可伪造 分布式账本技术
广义： 结合块链数据结构 密码学 分布式节点共识机制 智能合约等技术 确保数据的安全传输和访问 利用智能合约对数据编程和操作   计算平台
数据完整性和安全性保障 - 密码学 只能查询 不能篡改
数据共识性保障 共识机制
系统健壮性 数据被所有节点共同保存

公链：完全去中心化 任何人都可以进行交易和访问数据 缺点：交易成本高 效率低 交易时需要大多数节点验证
联盟连：部分去中心化  加入时需要进行验证和授权 通过预设的共识性机制 协调工作
私链：个人和实体开放 有中心组织 优势：成本低 速度快 更高的数据保密性 适用于严格监管的场景

核心区别
访问权限的开放程度和去中心化程度 联盟链和私链需要授权

区块链1.0
区块链层 基础技术和核心 共识过程 消息传递
协议层 软件服务 运行规则
货币层 价值转移
2.0
智能合约：运行在区块链上的自动执行脚本
以太坊 编写智能合约和Dapps
3.0
anywhere

核心技术
P2P技术、分布式账本技术DLT、共识算法（工作量证明、权益证明、委托权益证明）、密码算法、嵌入式数据库、智能合约
共识算法分为三类：
证明类：Pow、pos：
随机类：Algorand 和 POET（Proof of Elapsed Time）
联盟类：Dpos
各种优缺点 随后总结

开源项目：Hyperledger（fabric是核心实现）、Ethereum以太坊

2、共识机制基础
分布式一致性方案
2pc和3pc 提前写日志的方式来实现
2pc 由事务管理器来控制事务过程和参与资源管理
第一阶段：TM->RM 询问准备就绪 RM应答
第二阶段：all rm return yes tm -> rm commit ； any one timeout or response no tm 广播 rollback ；when finished rm -> tm return ack
优点：简单有效 强一致性；恢复能力
缺点：
阻塞问题：在第一阶段中，所有节点必须锁定其控制的资源，导致这些资源在事务提交期间无法被其他操作访问。
脑裂和恢复问题：
第二阶段 TM没有收到指令 数据临时不一致 如果参与节点在ack之前故障 必须等所有节点恢复后才能解决
单点故障：Tm故障

3pc：为了解决2pc中的阻塞和潜在的脑裂问题 引入预提交和参与者的超时机制增强鲁棒性
1.询问提交 ：TM->RM cancommit 和启动超时
2、预提交：all RM return yes Tm send precommit ；rm 将事务的undo和redo日志 写入稳定存储 恢复yes和no 之后启动另一个超时机制  如果没有收到最终指令 参与者会根据预提交状态直接提交事务
3、最终提交：如果所有参与者在预提交阶段都回复“Yes”，协调节点则发出“DoCommit”指令。参与者收到后执行最终提交，向协调者发送最终的确认响应（Ack）。如果有参与者回答“No”或响应超时，协调节点会指示所有参与者根据 undo 日志回滚事务。

注意点
如果协调者在最后阶段宕机，那些未收到“DoCommit”指令的参与者将在超时后直接提交事务。
如果参与者在收到回滚指令后完成回滚，也需要向协调者发送确认响应（Ack）。

优点：
减少阻塞，通过引入预提交阶段和参与者的超时机制，3PC 减少了参与者因等待协调节点的指令而产生的阻塞。
增强决策能力：参与者能根据自己的日志在超时情况下自主决定提交或回滚，增强了系统在协调节点故障时的独立性。

缺点：
潜在的数据不一致：在网络分区的情况下，已经进入预提交阶段的节点在超时后可能会提交事务，而未接收到预提交指令的节点则会回滚，导致数据不一致。即使网络恢复，新的协调者也难以判断事务的正确状态。

拜占庭将军问题：
拜占庭将军问题本质是对分布式系统如何在不可靠组件和恶意行为下达成一致的深刻隐喻。它不仅提出了理论极限（如3m+1的节点要求），更推动了拜占庭容错（BFT）技术的发展，成为构建高可靠性、去中心化系统的基石。其核心启示在于：在充满不确定性的环境中，唯有通过冗余通信与严格的验证机制，才能淬炼出真正的共识。

共识算法必须满足的三个特性：
一致性：所有节点必须同意某个决策值，确保系统操作的整体一致性。
有效性（正确性）：被所有节点接受的决策值必须由这些节点中的至少一个提出，保证决策的合法性和相关性。
终止性（可结束性）：所有节点最终都能完成决策过程，确保系统不会无限期地等待而无法前进。

FLP定理：FLP 定理：在一个异步通信网络中，只要存在一个故障节点，就不存在一种完美的共识算法可以正确地终止（使所有节点达成一致）。

CAP定理：
强一致性（Consistency）：确保所有节点在完成写操作后能返回最新的数据。若不是最新的数据，则返回错误。这种级别的一致性要求非常高，实际应用中往往采用更灵活、成本更低的一致性模型，如最终一致性。
可用性（Availability）：系统必须确保对客户端的每个请求都能在一定时间内给予响应，无论请求的结果如何，保证服务的持续可用。
分区容错性（Partition tolerance）：即使出现网络分区，部分节点之间失去通信，系统仍需能继续运行。

共识算法的分类：
容错类型：
拜占庭容错共识算法：包括 PBFT、PoW（工作量证明）、PoS（权益证明）、DPoS（委托权益证明）等。这类算法能够在节点可能存在恶意行为的环境中维持网络的一致性和安全。
非拜占庭容错共识算法：如 Paxos、Raft 等。这些算法假设节点基本诚实，主要解决的是因网络故障或节点失效导致的问题。
在公链环境中，通常采用拜占庭容错算法，以抵御潜在的恶意攻击；而在联盟链中，则可以根据参与方之间的信任程度选择合适的算法。

算法稳定性
共识算法按照其决策的确定性可以分为：
确定性共识算法：如 Paxos、Raft、PBFT 等。这些算法一旦达成共识，其决策就是最终的，不存在回退的可能性。
概率性共识算法：如 PoW、部分 PoS 等。这类算法达成的共识可能会在未来某个时间点被回退，但这种概率随时间延长逐渐趋近于零。
确定性共识算法通常用于需要高可靠性的系统，而概率性共识算法则常见于公链环境，其中对安全性和去中心化有更高的要求。

选主策略
共识算法在节点如何成为出块节点这一决策上也有所不同：
选举类共识算法：如 Raft、PBFT。这些算法通过节点间的投票机制来选举出块节点，选举出的节点可以在多轮中连续作为出块节点。
证明类共识算法：如 PoW、PoS。这些算法要求节点通过展示其计算能力或持有的货币量等方式来赢得出块的权利，通常每轮选举的出块节点都是不同的，以增强系统的公平性和安全性。

传统分布式一致性算法
1、Paxos
关键特性：
安全性：Paxos 确保所有非故障节点都会达成一致的决策，且这些决策必须由参与的节点中的某些节点提出，确保了系统的一致性。
无保证的终止性：虽然 Paxos 设计目的是最终达成一致，但在某些极端的异步条件下，可能不会达到最终决策的状态。这不保证算法在所有情况下都能迅速收敛至一个共识结果。
容错性：Paxos 可以容忍少于半数的节点出现宕机或故障。在这种情况下，剩余的健康节点仍然有能力达成共识，保持系统的运行。

Basic Paxos大致流程：
角色定义：
Proposer（提议者）：负责发起提案，希望被选为领导者（Leader）。Proposer 将提议值广播给 Acceptor，并收集他们的投票以决定最终的提议值。系统中可以同时存在多个 Proposer。
Acceptor（接受者）：接收 Proposer 的提议值，并根据特定规则决定是否接受这个提议。
Learner（学习者）：不直接参与投票，但需要知晓并遵循最终被选定的提议值。
Leader（领导者）：从众多 Proposer 中选出的领导者，其提议值被系统其他成员遵守。

阶段一：准备阶段
1、提议发起：
当一个节点（称为 Proposer）决定发起一个新的提案，集群中的多数节点发送 Prepare 请求。
2、Acceptor 的响应：
每个收到 Prepare 请求的节点（称为 Acceptor）首先检查请求中的提案编号 N。
如果提案编号 N 小于或等于该 Acceptor 已经响应过的最大提案编号 Nh（N ≤ Nh），Acceptor 将向 Proposer 发送 Reject 消息，拒绝该提案。
如果提案编号 N 大于 Acceptor 响应过的任何提案编号（N > Nh），Acceptor 将执行以下操作：
发送一个承诺消息 Promise(Na, Va)给 Proposer，其中 Na是该 Acceptor 之前接受的最大提案编号，Va是与 Na相关联的提议值。
更新其内部记录的 Nh至 N，表示承诺不再接受任何编号小于 N 的提案。
如果该 Acceptor 从未接受过任何提案，它将发送 Promise(Null, Null)消息，表示其承诺是基于没有先前承诺的状态。
通过这种方式，Paxos 算法的准备阶段确保所有的 Acceptor 都对即将进行的提议投票过程有共同的理解，并为 Proposer 提供了关于集群当前状态的重要信息，从而支持其决策过程。这个阶段是建立共识过程中信任和一致性的基础。

阶段二：接受阶段
1、评估响应：
如果 Proposer 从超过半数的节点收到了对其 Prepare(N)请求的正面响应，它将继续评估这些响应。
从接收到的 Promise 消息中，Proposer 找出具有最大提案号的响应（Promise(Nn, Vn)），并选择与之相关的提议值 Vn作为共识提议。
如果所有响应中的提议值均为 Null，表明没有有效的先前提议，Proposer 则可选择一个新的提议值 V，并发起 Accept(N, V)请求。
如果接收到任何 Reject 消息，这表明存在一个更高编号的提案已被提出。在这种情况下，Proposer 需回到阶段一重新发起新的 Prepare 请求，使用更高的提案号。
2、处理 Accept 请求：
当 Acceptor 收到 Accept(N, V)请求时，它将检查请求中的 N 与本地记录的最大响应编号 Nh。
如果 N 大于 Nh，表明这个 Accept 请求有效，Acceptor 则同意这个请求，发送 Agree 响应给 Proposer，并更新本地的 Nh和 Na为 N，Va为 V，表明已接受该提议。
如果 N 小于或等于 Nh，则 Acceptor 将拒绝这个请求并发送 Reject 消息给 Proposer，因为根据协议规则，Acceptor 不能接受编号小于或等于之前承诺过的提案号的提议。
这个阶段是确保提议得到足够多的接受并防止老旧提议干扰新的共识过程的关键。成功的话，这将为系统中的节点建立一个新的、被大多数节点接受的共识值，从而维护系统的整体一致性和稳定性。

活锁问题：
在 Paxos 算法的接受阶段，一个常见的问题是活锁。活锁发生时，多个 Proposer 可能因为互相覆盖对方的提案（通过提出更高编号的提案）而导致系统无法进入稳定的共识状态。
这主要是因为当 Proposer 收到 Reject 响应后，会重新发起带有更高提案号的 Prepare 请求，从而触发新一轮的共识尝试。如果多个 Proposer 并行工作，这种情况可以不断重复，从而使系统陷入一个循环，无法达到最终共识。

解决活锁的策略包括：
1、固定 Proposer 选举：
通过选择一个固定的 Proposer，可以减少提案号的竞争和相互覆盖，从而降低活锁的发生率。在这种设置中，只有一个选定的 Proposer 负责发起提案，其他节点则作为 Acceptor 参与共识过程。
2、设置超时和随机化机制：
给不同的 Proposer 设置不同的超时时间或随机化提案号的生成策略可以有效地减少同时发起提案的概率。通过这种方式，可以减少 Proposer 之间的直接竞争，允许系统有更多的机会达成一致。
这种方法在异步网络环境中尤其有用，因为即使在网络延迟或其他不确定因素的影响下，这种随机化和超时设置也可以帮助避免提案的直接冲突。

对FLP定理优化：
1、保证安全性（Safety）：
当 Proposer 能从过半数的 Acceptor 接收到响应时，Paxos 确保这些响应是基于最新的、有效的共识尝试。这样即使在异步环境下，只要足够多的节点能响应，系统仍能保持一致性并达成共识。
这种设计确保了任何已达成的共识都是正确的，即所有非故障节点在任何时候都同意同一个决策。
2、活性（Liveness）的牺牲：
如果 Proposer 无法从过半数的 Acceptor 获得响应，Paxos 不保证共识能立即完成。这种情况下，共识过程可能会进入停滞状态，直到网络通信恢复并且足够多的节点能够再次参与投票。
这种停滞不是永久性的；一旦条件允许，共识过程可以恢复并最终达成。这种设计虽牺牲了一部分活性，但是在不稳定的网络环境中，它提供了对安全性的强保证。
Paxos 算法的这种处理方式，即在异步网络中牺牲部分活性以确保系统安全性，展示了在现实世界应用中如何接受理论限制并优化算法设计。这种权衡在设计需要高度可靠性的分布式系统时尤其重要，因为在这些系统中，维持数据的一致性和正确性是至关重要的。

缺点：
复杂性、实用挑战性、二次设计

2、Raft 专门用于管理日志的一致性算法
角色：
Leader： Leader 负责处理所有客户端请求。如果 Follower 节点接收到客户端的请求，它会将请求转发给 Leader。当存在一个 Leader 时，系统中不会有 Candidate 节点。
Candidate： Candidate 是在选举 Leader 阶段出现的临时状态。任何节点在检测到现有 Leader 故障或任期结束时可以成为 Candidate。
Follower： 这是节点的默认初始状态。Followers 处于被动接收状态，不会主动发起请求。如果在选举期间 Follower 没有收到来自 Leader 的心跳信号，它将转变为 Candidate 状态，并参与 Leader 的竞选。
在 Raft 协议中，时间被划分为若干个“任期”（term），每个任期由一个独特的连续编号标识。每个任期开始时都会进行一次选举，如果某个 Candidate 赢得了多数票，则它将在该任期剩余时间内担任 Leader。如果选举结果未能明确产生一位 Leader，则系统将立刻进入下一个任期并重新进行选举。这种机制确保了系统的一致性和高可用性，同时也易于理解和实现，使得 Raft 成为处理分布式系统一致性问题的流行选择。

过程详解：
阶段一：Leader 选举
在 Raft 协议中，所有节点初始状态为 Follower。Follower 角色的节点会保持监听状态，接收来自 Leader 或 Candidate 的消息。
Leader 负责维护自己的领导地位，通过向所有 Follower 定期发送心跳消息来实现。如果一个 Follower 在设定的周期（通常是 150~300 毫秒）内未收到心跳，它便会认为当前无有效的 Leader，并启动选举流程，自我提升为 Candidate。

启动选举：
Follower 首先增加自己的任期号，然后变更其状态为 Candidate。
该 Candidate 为自己投票，并向其他节点发送 RequestVote 请求以寻求支持。
选举结果：
如果 Candidate 在当前任期内获得了超过半数节点的投票，它则胜出，成为新的 Leader。
作为 Leader，它将开始定期向所有节点发送心跳消息，确认自己的领导地位并阻断可能的新选举。
接收到心跳：
在等待投票结果期间，Candidate 可能会收到新 Leader 的心跳消息。
如果心跳消息中的任期号大于 Candidate 当前的任期号，Candidate 将承认新 Leader 的合法性并转变回 Follower 状态。
如果心跳任期号不大于自己的任期号，Candidate 将继续保持 Candidate 状态并等待选举结果。
选举超时：
如果在一定时间内没有 Candidate 赢得选举，通常是因为多个 Candidate 同时竞争导致票数分散。
此时，每个 Candidate 将在随机延时后再次发起选举，延时时间设置在 150~300 毫秒内，目的是减少同时触发的可能性，从而提高成功选举的几率。

阶段二：日志复制（对应区块中的记账过程）
一旦 Leader 被选出，它便开始处理来自客户端的请求。每个请求包含一条命令，这条命令需要通过状态机来执行。Leader 首先将命令添加到自己的日志中作为新的日志条目。随后，Leader 向其他 Follower 节点广播 AppendEntries 请求，这一请求包含日志条目的内容，要求 Follower 节点复制该日志条目。
当日志条目在所有节点上成功复制后，Leader 将其应用到自己的状态机，并向客户端反馈执行结果。如果在一定时间内 Follower 没有响应（可能由于崩溃、执行延迟或网络问题），Leader 将持续重发 AppendEntries 请求，直到所有 Follower 成功存储该日志条目为止。=
一旦日志条目被大多数节点复制，该条目便达到了可提交的状态（Committed）。此时，Leader 记录下这个条目在日志中的最高序号，并在后续的 AppendEntries 请求（包括心跳消息）中包含这个序号，以通知其他节点该日志条目已经被提交。Follower 收到这个信息后，会将日志条目应用到自己的本地状态机中执行。
这个过程不仅确保了数据的一致性和完整性，还提高了系统的可靠性和效率，使得 Raft 算法特别适合处理区块链等需要高可靠性记账处理的分布式系统。

阶段三：Leader失联
在日志复制阶段（阶段二），如果出现网络故障或网络分区事件，可能导致现任 Leader 无法与大多数 Follower 保持联系。在这种情况下，那些失去与 Leader 联系的 Follower 将触发新一轮的领导选举。
如果在 Leader 失联期间已经选出了新的 Leader，旧 Leader 在重新连接后将自动降级为 Follower。此外，旧 Leader 在失联期间所做的任何更新将被认为无效并需进行回滚，以确保系统状态的一致性。

区块链共识算法：
如何选择？
根据两种思路选择：
公链项目，考虑节点规模和安全性。通常选择能够容忍拜占庭故障的共识算法，如 PoW、Pos、DPoS 等；
联盟链和私链项目，更考虑高性能和低延迟。通常选择经典 PBFT、Raft 等。

POW:PoW 算法就是通过基于算力的随机性竞争记账的方式，来选出一个记账节点打包区块，然后向其他节点广播这个新增区块信息。从此解决去中心化系统中的记账一致性问题。 那么如何比拼算力？具体来说就是一份确认工作量的证明。节点需要消耗一定算力去计算以完成工作得出结果，然后交给验证方进行验证，验证工作是可以很快的。
三要素：
工作量证明函数：不断枚举 Nonce 并哈希的过程，PoW 使用的哈希函数就是 Sha-256
区块：这道题的输入数据，代替上述字符串「blockchain」；区块由区块头和区块体组成。区块头为 80B，包含 4B 的版本号、32B 的上个区块的哈希值、32B 的
默克尔根哈希值、4B 的时间戳（当前时间）、4B 的当前难度值（实际存的是难度值转换后的目标哈希值,通常表示为 nBits）、4B 的随机数组成。区块体就是交易列表，其中第一笔交易是 CoinBase。
难度值：是比特币节点生成区块时的重要参考指标，它决定了节点大约需要经过多少次哈希运算才能产生一个合法区块。

最长链原则：选择一条最长的链作为主链，矿工挖矿与数据同步都以最长链为标准，如果存在长度相同的链，就从中随机选择一条进行挖矿。存在于在非主链上的区块中的交易， 在主链上都不作数，相当于进行了「回滚」。
缺点：资源浪费、导致难以被更大规模应用接受。

POS共识：节点通过投入一定量的虚拟币参与共识，根据持币情况获得打包新区块的权利，并获得奖励。
基本概念：
验证者：在 PoS 中，参与共识的节点被称为验证者节点（Validator）。任何拥有虚拟币的节点都可以通过发送特殊交易的方式，将部分虚拟货币转为股份，以成为验证者。完整的验证者节点集合由区块链系统维护。
币龄：为了描述持币情况，PoS 共识算法引入了币龄（Coinage）概念，表示持有部分虚拟货币的时长。当节点将虚拟币作为股份投入后，这部分虚拟币就开始积累币龄，
币龄计算方式：Coinage=k * balance * age; 币龄在使用对应虚拟币（用于区块生成或交易）后会被销毁。节点币龄越大，越容易生成区块。

共识流程：
PoS 算法在打包区块时，将同时考虑币龄和哈希计算难度，使得节点只需要消耗很少的计算资源就可以出块。

DPOS：随着项目发展，它们都逐渐具有一定的中心化特性，即拥有高算力或高代币余额的节点优先拥有记账权，DPoS 的出现解决了这个不足。
DPoS 是目前看到的最快、最高效和最灵活（但不去中心化）的共识算法。委托权益证明（Delegated Proof of Stake, DPoS）利用权益人投票的权利来公平民主的解决共识问题。

DPoS 的优缺点
优点：
不需要耗费能源和硬件设备；缩短了区块的产生时间和确认时间，提高了系统效率。
DPoS 不需要挖矿，也不需要全节点验证，而是由有限数量的见证节点进行验证，因此简单、高效。
缺点：
为了提高效率，DPoS 以代理人共识取代全网共识，因此时常被抨击与区块链去中心化的理念相违背。

DPoS 的共识流程主要就是投票选出见证人，并由见证人轮流进行区块生成的循环流程。系统在每轮循环中都会重新统计候选人得票，并选出 N 个见证人，并把它们的排序打乱，
然后见证人轮流生成区块。在一个生成周期结束后，再重新进行见证人选举。

PBTF算法：降低了拜占庭协议的运行复杂度，从指数级别降低到多项式级别。
一致性协议：
一致性协议包含 5 个阶段：请求（Request）、序号分配（Pre-Prepare）、交互（Prepare）、序号确认（Commit）和响应/执行（Reply/Execute）。
1.Request（请求）阶段】

客户端发生请求给主节点，请求消息 m=[op,ts,c-id,c-sig]，其中 op 是需要执行的操作，ts 是时间戳，c-id 是客户端 ID，c-sig 是客户端签名。时间戳是为了保证命令只被执行一次，

客户端的签名是方便客户认证和权限控制。

【2.Pre-Prepare（序号分配）阶段】

主节点会给请求分配一个序列号 sn，并构造 Pre-Prepare 消息[PP,vn,sn,D(m),p-sig,m]给其他从节点，其中 PP 表示 Pre-Prepare 消息，vn 是视图号，D(m)是消息摘要，

p-sig 是主节点签名，m 是客户消息。序列号是为了保证命令执行顺序，视图号让从节点记录当前视图，主节点签名是为了让从节点认证主节点身份，而消息摘要是为了保证消息没有篡改。

【3. Prepare（交互）阶段】

从节点接受 PP 消息，然后向其他从节点广播 Prepare 消息[P,vn,sn,D(m),b-id,b-sig]，其中 P 表示 Prepare 消息，b-id 是从节点 ID，b-sig 是从节点签名。

【4. Commit（序号确认）阶段】

从节点在收到 2f+1 个 Prepare 消息后，对视图内的请求和次序进行验证，然后广播 Commit 消息[C,vn,sn,D(m),b-id,b-sig]，其中 C 表示 Commit 消息。

【5. Reply/Execute（响应）阶段】

当各节点收到 2f+1 个 Commit 消息后，它们将执行操作并提交，同时把回复返回给客户端。回复消息是[R,vn,ts,b-sig]，R 是回复消息。客户端等待不同节点的回复，

若有 f+1 个回复一致，则接受该回复。

Casper共识算法 后续补充






