1.区块链基础
区块链简介
狭义：链式数据结构 通过时间顺序链接 通过密码学 不可篡改 不可伪造 分布式账本技术
广义： 结合块链数据结构 密码学 分布式节点共识机制 智能合约等技术 确保数据的安全传输和访问 利用智能合约对数据编程和操作   计算平台
数据完整性和安全性保障 - 密码学 只能查询 不能篡改
数据共识性保障 共识机制
系统健壮性 数据被所有节点共同保存

公链：完全去中心化 任何人都可以进行交易和访问数据 缺点：交易成本高 效率低 交易时需要大多数节点验证
联盟连：部分去中心化  加入时需要进行验证和授权 通过预设的共识性机制 协调工作
私链：个人和实体开放 有中心组织 优势：成本低 速度快 更高的数据保密性 适用于严格监管的场景

核心区别
访问权限的开放程度和去中心化程度 联盟链和私链需要授权

区块链1.0
区块链层 基础技术和核心 共识过程 消息传递
协议层 软件服务 运行规则
货币层 价值转移
2.0
智能合约：运行在区块链上的自动执行脚本
以太坊 编写智能合约和Dapps
3.0
anywhere

核心技术
P2P技术、分布式账本技术DLT、共识算法（工作量证明、权益证明、委托权益证明）、密码算法、嵌入式数据库、智能合约
共识算法分为三类：
证明类：Pow、pos：
随机类：Algorand 和 POET（Proof of Elapsed Time）
联盟类：Dpos
各种优缺点 随后总结

开源项目：Hyperledger（fabric是核心实现）、Ethereum以太坊

2、共识机制基础
分布式一致性方案
2pc和3pc 提前写日志的方式来实现
2pc 由事务管理器来控制事务过程和参与资源管理
第一阶段：TM->RM 询问准备就绪 RM应答
第二阶段：all rm return yes tm -> rm commit ； any one timeout or response no tm 广播 rollback ；when finished rm -> tm return ack
优点：简单有效 强一致性；恢复能力
缺点：
阻塞问题：在第一阶段中，所有节点必须锁定其控制的资源，导致这些资源在事务提交期间无法被其他操作访问。
脑裂和恢复问题：
第二阶段 TM没有收到指令 数据临时不一致 如果参与节点在ack之前故障 必须等所有节点恢复后才能解决
单点故障：Tm故障

3pc：为了解决2pc中的阻塞和潜在的脑裂问题 引入预提交和参与者的超时机制增强鲁棒性
1.询问提交 ：TM->RM cancommit 和启动超时
2、预提交：all RM return yes Tm send precommit ；rm 将事务的undo和redo日志 写入稳定存储 恢复yes和no 之后启动另一个超时机制  如果没有收到最终指令 参与者会根据预提交状态直接提交事务
3、最终提交：如果所有参与者在预提交阶段都回复“Yes”，协调节点则发出“DoCommit”指令。参与者收到后执行最终提交，向协调者发送最终的确认响应（Ack）。如果有参与者回答“No”或响应超时，协调节点会指示所有参与者根据 undo 日志回滚事务。

注意点
如果协调者在最后阶段宕机，那些未收到“DoCommit”指令的参与者将在超时后直接提交事务。
如果参与者在收到回滚指令后完成回滚，也需要向协调者发送确认响应（Ack）。

优点：
减少阻塞，通过引入预提交阶段和参与者的超时机制，3PC 减少了参与者因等待协调节点的指令而产生的阻塞。
增强决策能力：参与者能根据自己的日志在超时情况下自主决定提交或回滚，增强了系统在协调节点故障时的独立性。

缺点：
潜在的数据不一致：在网络分区的情况下，已经进入预提交阶段的节点在超时后可能会提交事务，而未接收到预提交指令的节点则会回滚，导致数据不一致。即使网络恢复，新的协调者也难以判断事务的正确状态。

拜占庭将军问题：
拜占庭将军问题本质是对分布式系统如何在不可靠组件和恶意行为下达成一致的深刻隐喻。它不仅提出了理论极限（如3m+1的节点要求），更推动了拜占庭容错（BFT）技术的发展，成为构建高可靠性、去中心化系统的基石。其核心启示在于：在充满不确定性的环境中，唯有通过冗余通信与严格的验证机制，才能淬炼出真正的共识。

共识算法必须满足的三个特性：
一致性：所有节点必须同意某个决策值，确保系统操作的整体一致性。
有效性（正确性）：被所有节点接受的决策值必须由这些节点中的至少一个提出，保证决策的合法性和相关性。
终止性（可结束性）：所有节点最终都能完成决策过程，确保系统不会无限期地等待而无法前进。

FLP定理：FLP 定理：在一个异步通信网络中，只要存在一个故障节点，就不存在一种完美的共识算法可以正确地终止（使所有节点达成一致）。

CAP定理：
强一致性（Consistency）：确保所有节点在完成写操作后能返回最新的数据。若不是最新的数据，则返回错误。这种级别的一致性要求非常高，实际应用中往往采用更灵活、成本更低的一致性模型，如最终一致性。
可用性（Availability）：系统必须确保对客户端的每个请求都能在一定时间内给予响应，无论请求的结果如何，保证服务的持续可用。
分区容错性（Partition tolerance）：即使出现网络分区，部分节点之间失去通信，系统仍需能继续运行。

共识算法的分类：
容错类型：
拜占庭容错共识算法：包括 PBFT、PoW（工作量证明）、PoS（权益证明）、DPoS（委托权益证明）等。这类算法能够在节点可能存在恶意行为的环境中维持网络的一致性和安全。
非拜占庭容错共识算法：如 Paxos、Raft 等。这些算法假设节点基本诚实，主要解决的是因网络故障或节点失效导致的问题。
在公链环境中，通常采用拜占庭容错算法，以抵御潜在的恶意攻击；而在联盟链中，则可以根据参与方之间的信任程度选择合适的算法。

算法稳定性
共识算法按照其决策的确定性可以分为：
确定性共识算法：如 Paxos、Raft、PBFT 等。这些算法一旦达成共识，其决策就是最终的，不存在回退的可能性。
概率性共识算法：如 PoW、部分 PoS 等。这类算法达成的共识可能会在未来某个时间点被回退，但这种概率随时间延长逐渐趋近于零。
确定性共识算法通常用于需要高可靠性的系统，而概率性共识算法则常见于公链环境，其中对安全性和去中心化有更高的要求。

选主策略
共识算法在节点如何成为出块节点这一决策上也有所不同：
选举类共识算法：如 Raft、PBFT。这些算法通过节点间的投票机制来选举出块节点，选举出的节点可以在多轮中连续作为出块节点。
证明类共识算法：如 PoW、PoS。这些算法要求节点通过展示其计算能力或持有的货币量等方式来赢得出块的权利，通常每轮选举的出块节点都是不同的，以增强系统的公平性和安全性。

传统分布式一致性算法
1、Paxos
关键特性：
安全性：Paxos 确保所有非故障节点都会达成一致的决策，且这些决策必须由参与的节点中的某些节点提出，确保了系统的一致性。
无保证的终止性：虽然 Paxos 设计目的是最终达成一致，但在某些极端的异步条件下，可能不会达到最终决策的状态。这不保证算法在所有情况下都能迅速收敛至一个共识结果。
容错性：Paxos 可以容忍少于半数的节点出现宕机或故障。在这种情况下，剩余的健康节点仍然有能力达成共识，保持系统的运行。

Basic Paxos大致流程：
角色定义：
Proposer（提议者）：负责发起提案，希望被选为领导者（Leader）。Proposer 将提议值广播给 Acceptor，并收集他们的投票以决定最终的提议值。系统中可以同时存在多个 Proposer。
Acceptor（接受者）：接收 Proposer 的提议值，并根据特定规则决定是否接受这个提议。
Learner（学习者）：不直接参与投票，但需要知晓并遵循最终被选定的提议值。
Leader（领导者）：从众多 Proposer 中选出的领导者，其提议值被系统其他成员遵守。

阶段一：准备阶段
1、提议发起：
当一个节点（称为 Proposer）决定发起一个新的提案，集群中的多数节点发送 Prepare 请求。
2、Acceptor 的响应：
每个收到 Prepare 请求的节点（称为 Acceptor）首先检查请求中的提案编号 N。
如果提案编号 N 小于或等于该 Acceptor 已经响应过的最大提案编号 Nh（N ≤ Nh），Acceptor 将向 Proposer 发送 Reject 消息，拒绝该提案。
如果提案编号 N 大于 Acceptor 响应过的任何提案编号（N > Nh），Acceptor 将执行以下操作：
发送一个承诺消息 Promise(Na, Va)给 Proposer，其中 Na是该 Acceptor 之前接受的最大提案编号，Va是与 Na相关联的提议值。
更新其内部记录的 Nh至 N，表示承诺不再接受任何编号小于 N 的提案。
如果该 Acceptor 从未接受过任何提案，它将发送 Promise(Null, Null)消息，表示其承诺是基于没有先前承诺的状态。
通过这种方式，Paxos 算法的准备阶段确保所有的 Acceptor 都对即将进行的提议投票过程有共同的理解，并为 Proposer 提供了关于集群当前状态的重要信息，从而支持其决策过程。这个阶段是建立共识过程中信任和一致性的基础。

阶段二：接受阶段
1、评估响应：
如果 Proposer 从超过半数的节点收到了对其 Prepare(N)请求的正面响应，它将继续评估这些响应。
从接收到的 Promise 消息中，Proposer 找出具有最大提案号的响应（Promise(Nn, Vn)），并选择与之相关的提议值 Vn作为共识提议。
如果所有响应中的提议值均为 Null，表明没有有效的先前提议，Proposer 则可选择一个新的提议值 V，并发起 Accept(N, V)请求。
如果接收到任何 Reject 消息，这表明存在一个更高编号的提案已被提出。在这种情况下，Proposer 需回到阶段一重新发起新的 Prepare 请求，使用更高的提案号。
2、处理 Accept 请求：
当 Acceptor 收到 Accept(N, V)请求时，它将检查请求中的 N 与本地记录的最大响应编号 Nh。
如果 N 大于 Nh，表明这个 Accept 请求有效，Acceptor 则同意这个请求，发送 Agree 响应给 Proposer，并更新本地的 Nh和 Na为 N，Va为 V，表明已接受该提议。
如果 N 小于或等于 Nh，则 Acceptor 将拒绝这个请求并发送 Reject 消息给 Proposer，因为根据协议规则，Acceptor 不能接受编号小于或等于之前承诺过的提案号的提议。
这个阶段是确保提议得到足够多的接受并防止老旧提议干扰新的共识过程的关键。成功的话，这将为系统中的节点建立一个新的、被大多数节点接受的共识值，从而维护系统的整体一致性和稳定性。

活锁问题：
在 Paxos 算法的接受阶段，一个常见的问题是活锁。活锁发生时，多个 Proposer 可能因为互相覆盖对方的提案（通过提出更高编号的提案）而导致系统无法进入稳定的共识状态。
这主要是因为当 Proposer 收到 Reject 响应后，会重新发起带有更高提案号的 Prepare 请求，从而触发新一轮的共识尝试。如果多个 Proposer 并行工作，这种情况可以不断重复，从而使系统陷入一个循环，无法达到最终共识。

解决活锁的策略包括：
1、固定 Proposer 选举：
通过选择一个固定的 Proposer，可以减少提案号的竞争和相互覆盖，从而降低活锁的发生率。在这种设置中，只有一个选定的 Proposer 负责发起提案，其他节点则作为 Acceptor 参与共识过程。
2、设置超时和随机化机制：
给不同的 Proposer 设置不同的超时时间或随机化提案号的生成策略可以有效地减少同时发起提案的概率。通过这种方式，可以减少 Proposer 之间的直接竞争，允许系统有更多的机会达成一致。
这种方法在异步网络环境中尤其有用，因为即使在网络延迟或其他不确定因素的影响下，这种随机化和超时设置也可以帮助避免提案的直接冲突。

对FLP定理优化：
1、保证安全性（Safety）：
当 Proposer 能从过半数的 Acceptor 接收到响应时，Paxos 确保这些响应是基于最新的、有效的共识尝试。这样即使在异步环境下，只要足够多的节点能响应，系统仍能保持一致性并达成共识。
这种设计确保了任何已达成的共识都是正确的，即所有非故障节点在任何时候都同意同一个决策。
2、活性（Liveness）的牺牲：
如果 Proposer 无法从过半数的 Acceptor 获得响应，Paxos 不保证共识能立即完成。这种情况下，共识过程可能会进入停滞状态，直到网络通信恢复并且足够多的节点能够再次参与投票。
这种停滞不是永久性的；一旦条件允许，共识过程可以恢复并最终达成。这种设计虽牺牲了一部分活性，但是在不稳定的网络环境中，它提供了对安全性的强保证。
Paxos 算法的这种处理方式，即在异步网络中牺牲部分活性以确保系统安全性，展示了在现实世界应用中如何接受理论限制并优化算法设计。这种权衡在设计需要高度可靠性的分布式系统时尤其重要，因为在这些系统中，维持数据的一致性和正确性是至关重要的。

缺点：
复杂性、实用挑战性、二次设计

2、Raft 专门用于管理日志的一致性算法
角色：
Leader： Leader 负责处理所有客户端请求。如果 Follower 节点接收到客户端的请求，它会将请求转发给 Leader。当存在一个 Leader 时，系统中不会有 Candidate 节点。
Candidate： Candidate 是在选举 Leader 阶段出现的临时状态。任何节点在检测到现有 Leader 故障或任期结束时可以成为 Candidate。
Follower： 这是节点的默认初始状态。Followers 处于被动接收状态，不会主动发起请求。如果在选举期间 Follower 没有收到来自 Leader 的心跳信号，它将转变为 Candidate 状态，并参与 Leader 的竞选。
在 Raft 协议中，时间被划分为若干个“任期”（term），每个任期由一个独特的连续编号标识。每个任期开始时都会进行一次选举，如果某个 Candidate 赢得了多数票，则它将在该任期剩余时间内担任 Leader。如果选举结果未能明确产生一位 Leader，则系统将立刻进入下一个任期并重新进行选举。这种机制确保了系统的一致性和高可用性，同时也易于理解和实现，使得 Raft 成为处理分布式系统一致性问题的流行选择。

过程详解：
阶段一：Leader 选举
在 Raft 协议中，所有节点初始状态为 Follower。Follower 角色的节点会保持监听状态，接收来自 Leader 或 Candidate 的消息。
Leader 负责维护自己的领导地位，通过向所有 Follower 定期发送心跳消息来实现。如果一个 Follower 在设定的周期（通常是 150~300 毫秒）内未收到心跳，它便会认为当前无有效的 Leader，并启动选举流程，自我提升为 Candidate。

启动选举：
Follower 首先增加自己的任期号，然后变更其状态为 Candidate。
该 Candidate 为自己投票，并向其他节点发送 RequestVote 请求以寻求支持。
选举结果：
如果 Candidate 在当前任期内获得了超过半数节点的投票，它则胜出，成为新的 Leader。
作为 Leader，它将开始定期向所有节点发送心跳消息，确认自己的领导地位并阻断可能的新选举。
接收到心跳：
在等待投票结果期间，Candidate 可能会收到新 Leader 的心跳消息。
如果心跳消息中的任期号大于 Candidate 当前的任期号，Candidate 将承认新 Leader 的合法性并转变回 Follower 状态。
如果心跳任期号不大于自己的任期号，Candidate 将继续保持 Candidate 状态并等待选举结果。
选举超时：
如果在一定时间内没有 Candidate 赢得选举，通常是因为多个 Candidate 同时竞争导致票数分散。
此时，每个 Candidate 将在随机延时后再次发起选举，延时时间设置在 150~300 毫秒内，目的是减少同时触发的可能性，从而提高成功选举的几率。

阶段二：日志复制（对应区块中的记账过程）
一旦 Leader 被选出，它便开始处理来自客户端的请求。每个请求包含一条命令，这条命令需要通过状态机来执行。Leader 首先将命令添加到自己的日志中作为新的日志条目。随后，Leader 向其他 Follower 节点广播 AppendEntries 请求，这一请求包含日志条目的内容，要求 Follower 节点复制该日志条目。
当日志条目在所有节点上成功复制后，Leader 将其应用到自己的状态机，并向客户端反馈执行结果。如果在一定时间内 Follower 没有响应（可能由于崩溃、执行延迟或网络问题），Leader 将持续重发 AppendEntries 请求，直到所有 Follower 成功存储该日志条目为止。=
一旦日志条目被大多数节点复制，该条目便达到了可提交的状态（Committed）。此时，Leader 记录下这个条目在日志中的最高序号，并在后续的 AppendEntries 请求（包括心跳消息）中包含这个序号，以通知其他节点该日志条目已经被提交。Follower 收到这个信息后，会将日志条目应用到自己的本地状态机中执行。
这个过程不仅确保了数据的一致性和完整性，还提高了系统的可靠性和效率，使得 Raft 算法特别适合处理区块链等需要高可靠性记账处理的分布式系统。

阶段三：Leader失联
在日志复制阶段（阶段二），如果出现网络故障或网络分区事件，可能导致现任 Leader 无法与大多数 Follower 保持联系。在这种情况下，那些失去与 Leader 联系的 Follower 将触发新一轮的领导选举。
如果在 Leader 失联期间已经选出了新的 Leader，旧 Leader 在重新连接后将自动降级为 Follower。此外，旧 Leader 在失联期间所做的任何更新将被认为无效并需进行回滚，以确保系统状态的一致性。

区块链共识算法：
如何选择？
根据两种思路选择：
公链项目，考虑节点规模和安全性。通常选择能够容忍拜占庭故障的共识算法，如 PoW、Pos、DPoS 等；
联盟链和私链项目，更考虑高性能和低延迟。通常选择经典 PBFT、Raft 等。

POW:PoW 算法就是通过基于算力的随机性竞争记账的方式，来选出一个记账节点打包区块，然后向其他节点广播这个新增区块信息。从此解决去中心化系统中的记账一致性问题。 那么如何比拼算力？具体来说就是一份确认工作量的证明。节点需要消耗一定算力去计算以完成工作得出结果，然后交给验证方进行验证，验证工作是可以很快的。
三要素：
工作量证明函数：不断枚举 Nonce 并哈希的过程，PoW 使用的哈希函数就是 Sha-256
区块：这道题的输入数据，代替上述字符串「blockchain」；区块由区块头和区块体组成。区块头为 80B，包含 4B 的版本号、32B 的上个区块的哈希值、32B 的
默克尔根哈希值、4B 的时间戳（当前时间）、4B 的当前难度值（实际存的是难度值转换后的目标哈希值,通常表示为 nBits）、4B 的随机数组成。区块体就是交易列表，其中第一笔交易是 CoinBase。
难度值：是比特币节点生成区块时的重要参考指标，它决定了节点大约需要经过多少次哈希运算才能产生一个合法区块。

最长链原则：选择一条最长的链作为主链，矿工挖矿与数据同步都以最长链为标准，如果存在长度相同的链，就从中随机选择一条进行挖矿。存在于在非主链上的区块中的交易， 在主链上都不作数，相当于进行了「回滚」。
缺点：资源浪费、导致难以被更大规模应用接受。

POS共识：节点通过投入一定量的虚拟币参与共识，根据持币情况获得打包新区块的权利，并获得奖励。
基本概念：
验证者：在 PoS 中，参与共识的节点被称为验证者节点（Validator）。任何拥有虚拟币的节点都可以通过发送特殊交易的方式，将部分虚拟货币转为股份，以成为验证者。完整的验证者节点集合由区块链系统维护。
币龄：为了描述持币情况，PoS 共识算法引入了币龄（Coinage）概念，表示持有部分虚拟货币的时长。当节点将虚拟币作为股份投入后，这部分虚拟币就开始积累币龄，
币龄计算方式：Coinage=k * balance * age; 币龄在使用对应虚拟币（用于区块生成或交易）后会被销毁。节点币龄越大，越容易生成区块。

共识流程：
PoS 算法在打包区块时，将同时考虑币龄和哈希计算难度，使得节点只需要消耗很少的计算资源就可以出块。

DPOS：随着项目发展，它们都逐渐具有一定的中心化特性，即拥有高算力或高代币余额的节点优先拥有记账权，DPoS 的出现解决了这个不足。
DPoS 是目前看到的最快、最高效和最灵活（但不去中心化）的共识算法。委托权益证明（Delegated Proof of Stake, DPoS）利用权益人投票的权利来公平民主的解决共识问题。

DPoS 的优缺点
优点：
不需要耗费能源和硬件设备；缩短了区块的产生时间和确认时间，提高了系统效率。
DPoS 不需要挖矿，也不需要全节点验证，而是由有限数量的见证节点进行验证，因此简单、高效。
缺点：
为了提高效率，DPoS 以代理人共识取代全网共识，因此时常被抨击与区块链去中心化的理念相违背。

DPoS 的共识流程主要就是投票选出见证人，并由见证人轮流进行区块生成的循环流程。系统在每轮循环中都会重新统计候选人得票，并选出 N 个见证人，并把它们的排序打乱，
然后见证人轮流生成区块。在一个生成周期结束后，再重新进行见证人选举。

PBTF算法：降低了拜占庭协议的运行复杂度，从指数级别降低到多项式级别。
一致性协议：
一致性协议包含 5 个阶段：请求（Request）、序号分配（Pre-Prepare）、交互（Prepare）、序号确认（Commit）和响应/执行（Reply/Execute）。
1.Request（请求）阶段】

客户端发生请求给主节点，请求消息 m=[op,ts,c-id,c-sig]，其中 op 是需要执行的操作，ts 是时间戳，c-id 是客户端 ID，c-sig 是客户端签名。时间戳是为了保证命令只被执行一次，

客户端的签名是方便客户认证和权限控制。

【2.Pre-Prepare（序号分配）阶段】

主节点会给请求分配一个序列号 sn，并构造 Pre-Prepare 消息[PP,vn,sn,D(m),p-sig,m]给其他从节点，其中 PP 表示 Pre-Prepare 消息，vn 是视图号，D(m)是消息摘要，

p-sig 是主节点签名，m 是客户消息。序列号是为了保证命令执行顺序，视图号让从节点记录当前视图，主节点签名是为了让从节点认证主节点身份，而消息摘要是为了保证消息没有篡改。

【3. Prepare（交互）阶段】

从节点接受 PP 消息，然后向其他从节点广播 Prepare 消息[P,vn,sn,D(m),b-id,b-sig]，其中 P 表示 Prepare 消息，b-id 是从节点 ID，b-sig 是从节点签名。

【4. Commit（序号确认）阶段】

从节点在收到 2f+1 个 Prepare 消息后，对视图内的请求和次序进行验证，然后广播 Commit 消息[C,vn,sn,D(m),b-id,b-sig]，其中 C 表示 Commit 消息。

【5. Reply/Execute（响应）阶段】

当各节点收到 2f+1 个 Commit 消息后，它们将执行操作并提交，同时把回复返回给客户端。回复消息是[R,vn,ts,b-sig]，R 是回复消息。客户端等待不同节点的回复，

若有 f+1 个回复一致，则接受该回复。

Casper共识算法 后续补充

加密技术基础
对称加密：加密解密是相同秘钥 知名的算法：AES

AES：
分组长度：AES 算法将数据分组长度固定为 128 比特，以确保加密处理的统一性和效率。
密钥长度：AES 支持多种密钥长度选项，分别为 128 比特、192 比特和 256 比特。根据使用的密钥长度，AES 分为三个变体：AES-128, AES-192, 和 AES-256。
加密轮数：加密过程中的轮数（N）根据密钥长度不同而不同。AES-128 使用 10 轮加密，AES-192 使用 12 轮，而 AES-256 则使用 14 轮。这些加密轮数设计用于增强算法的安全性，使其能够抵御各种密码攻击。

分组密码工作模式
主要工作模式
ECB（Electronic Codebook）
描述：最简单的模式，单独加密每个 128 位明文分组，每个分组使用相同的密钥。
优点：简单，支持并行计算，没有误差传播。
缺点：相同明文分组产生相同密文分组，可能暴露固定内容的明文。

CBC（Cipher Block Chaining）
描述：明文分组在加密前与前一个密文分组进行异或操作。
优点：安全性较高。
缺点：存在错误传播，不支持并行计算。广泛应用于 SSL 和 IPSec。

CFB（Cipher Feedback）
描述：将分组密码转化为流密码模式，使用前一密文分组的部分比特和秘钥进行加密。
优点：适合加密小分组数据，通过更换初始向量（IV）可以有效隐藏明文内容。
缺点：存在比特级的错误传播。

OFB（Output Feedback）
描述：与 CFB 类似，但本次加密的输入是上一次加密的输出。
优点：没有错误传播，解决了 CBC 和 CFB 的错误传播问题。
缺点：需要频繁更换密钥或初始向量。

对称加密优点：对称密码算法的主要优势在于其开放性、低计算需求、快速加密速度和高加密效率。这些特性使得对称加密在需要快速处理大量数据的场景中非常有用。
缺点：秘钥管理，秘钥泄露风险

BTC原理基础
比特币技术细节
1.四个关键设计
P2P 网络技术：比特币的点对点（P2P）网络技术是其核心组成部分之一，使其能够作为一个去中心化的数字货币系统运行。在比特币网络中，所有的交易和区块都通过 P2P 网络传播，这种网络结构意味着没有中央服务器。每个网络节点都在本地保存完整的交易记录，并参与网络的管理。
分布式账本（区块链）：比特币通过分布式账本存储交易信息，没有中心机构，而是将数据存储在全网所有加入比特币网络的节点上。每个区块相当于一个小账本，记录了多笔交易信息和上一个区块的哈希地址。区块通过链式结构链接在一起，形成一个完整的账本体系。
工作量证明（Proof of Work，记账权）：为了保证每个账本的一致性，比特币引入了工作量证明机制。网络中的节点需要完成系统提供的数学题（即进行耗费算力和时间的哈希计算）才能获得记账权。谁先完成计算并满足条件，就优先获得记账权。这一机制不仅确保了账本的一致性，还保障了区块链的安全。
最长链原则：在传统交易中，由中心机构进行双花（双重支付）防护，但在区块链架构中，这一问题通过最长链原则来解决。同一笔钱的多次交易中，只有第一次交易有效，且这些交易不可能存在于同一个链条中。第二次交易所在区块一定是从主链上分叉出去的。
由于记账权的竞争依赖于算力，而比特币系统中任意节点都可以竞争记账权，主链增长速度更快，分叉链条则较慢。最终，由于攻击者的算力无法与全网算力竞争，只有主链会被系统承认，从而解决双花问题。

挖矿过程（原理）
打包交易：矿工从待确认交易的内存池中检索交易，并选择将其包含在区块中。矿工可以任意选择交易，甚至可以不选择任何交易（挖空块）。由于每个区块的容量有限（当前为 1MB），矿工无法无限制地选择交易。最合理的策略是根据手续费对待确认交易进行排序，然后从高到低尽量纳入最多的交易。
构造 Coinbase：确定了包含在区块中的交易后，矿工可以统计本区块的手续费总额，并结合比特币的产出规则，计算自己在本区块中的收益。
构造 hashMerkleRoot：对所有交易构造 Merkle 树，生成 hashMerkleRoot。
填充其他字段：在构造了交易集合和 Coinbase 后，填充区块头的其他字段，形成完整的区块头。
Hash 运算：对区块头进行 SHA256D 运算（双重 SHA-256 加密）。
验证结果：如果运算结果符合当前的难度目标，矿工会将新区块广播到整个网络，并开始挖下一个块；如果不符合难度要求，则根据一定策略改变区块头的某个字段后，再进行 Hash 运算并验证，直到找到符合难度目标的区块头为止。
这个算法也叫做 POW（Proof Of Work）
合格的区块条件： SHA256D(BlockHeader) < F(nBits)
其中，SHA256D(BlockHeader)就是挖矿结果，F(nBits)是难度对应的目标值，两者都是 256 位，都当成大整数处理，直接对比大小以判断是否符合难度要求。

哈希算法：
一个优秀的哈希算法需要满足以下要求：
不可逆性：无法通过输出值逆推回输入值。
低碰撞率：不同的输入值产生相同输出值的概率极低。

比特币中的Merkle Hash
在区块头部，有一个 MerkleRoot 字段。MerkleRoot 是通过将区块内所有交易记录的哈希值以二叉树结构不断合并计算得出的。以下是详细的计算过程：

检查交易数：如果交易总数为奇数，则复制最后一笔交易，以确保交易总数为偶数。
转换字节序：将每笔交易的哈希转换为小端序（比特币中的交易数据都是以小端序处理）。
拼接并哈希：将转换后的连续两个交易哈希拼接起来，然后计算两次哈希，即 sha256(sha256(tx1_hash_str + tx2_hash_str))，将结果作为父节点。
重复步骤：不断执行以上步骤，直到只剩下一个哈希值，将其转换为大端序，即得到 MerkleRoot。
如果只有一笔交易，直接使用该交易的哈希作为 MerkleRoot。通过这种金字塔式的合成方式，最终总能计算出 MerkleRoot。

MerkleRoot 的优点包括：
验证数据的完整性：确认数据未经修改。
占用较小空间：方便存储和传输。
高效验证：数据格式高效，验证数据完整性只需几分钟。
MerkleRoot 不仅在区块链中应用广泛，还在其他软件中得到应用，如 Git、Amazon DynamoDB 和 Apache Cassandra 等。

签名算法通常采用非对称加密算法，包含一对公钥和私钥。私钥由发送方保管，公钥可以公开。公私钥的作用是互补的：公钥加密由私钥解密，私钥加密由公钥解密。
在加密场景中，使用公钥加密，私钥解密；而在签名场景中，使用私钥加密，公钥解密。
常见的非对称加密算法包括：RSA、Elgamal、背包算法、Rabin、D-H、ECC 椭圆曲线加密算法。

数字签名在实际中的使用方法：
签名：发送方首先对明文消息进行哈希计算，得到消息哈希值，然后使用私钥加密该哈希值，生成加密摘要（即签名）。发送方将加密摘要（签名）和明文消息一起发送给接收方。
验证签名：接收方使用发送方提供的公钥解密加密摘要，得到消息哈希值。同时，接收方使用相同的哈希算法对明文消息进行哈希计算，并将计算得到的哈希值与解密得到的哈希值进行对比。如果两个哈希值一致，则消息未被篡改，且由发送方发出。

比特币对签名算法的使用
比特币使用签名算法（ECDSA）来实现交易签名，同时也作为一套账户方案。具体过程如下：

用户使用私钥对自己发起的交易进行签名。网络中的节点（矿工）使用公钥（同时作为账户地址）来验证该交易数据是否有效或被篡改。通过这种方式，比特币网络能够确保交易的真实性和完整性，防止篡改和欺诈行为。

通过私钥可以推出公钥，用户如果丢失私钥，则失去公钥账户下的所有资产。

在比特币系统中，私钥用于签名交易，本质上是一个 256 位的大整数。公钥则通过 ECDSA 算法从私钥中计算出来，这一过程不可逆推，因此无需保存公钥。

可以用银行卡作比较：公钥相当于银行卡号（由两个 256 位整数编码成一个地址），私钥相当于密码（一个 256 位整数）。与银行卡不同的是，比特币中需要先生成私钥（密码），再计算出公钥（卡号），因此公私钥是一一对应的，无法修改私钥。

匿名性

比特币账本是全网公开的，任何人都可以根据公钥查询余额，但无法知道公钥的拥有者是谁，这体现了比特币的匿名特性。

无限账户

与传统银行账户不同，比特币网络没有账户的概念。任何人都可以从区块链中查询任意公钥对应的比特币余额，但不知道这些公钥的持有者。因此，用户可以生成任意数量的私钥-公钥对，公钥用于接收比特币，私钥是唯一能花费比特币的手段。钱包程序帮助用户管理这些私钥-公钥对。

私钥编码

由于私钥是一个 256 位整数，太长而难以记忆。比特币采用 Base58 编码对私钥进行编码，有非压缩和压缩两种编码格式，分别对应非压缩和压缩的公钥格式。

推导公钥

根据 ECDSA 算法，一个 256 位整数的私钥可以推导出两个 256 位整数（公钥），记作（x, y），这是非压缩公钥。根据 ECC 曲线特点，通过非压缩公钥（x, y）中的 x 可以推算出 y，但需要知道 y 的奇偶性。因此，非压缩公钥可以记录为压缩公钥 x'。压缩格式的公钥只保存 x，并在前面添加 02（y 为偶数）或 03（y 为奇数）前缀，得到一个 33 字节的压缩公钥数据 x'。压缩和非压缩公钥可以互相转换，但均不可反向推导出私钥。目前，非压缩公钥因其签名脚本数据较长，已很少使用。

比特币地址（即收款地址）

早期比特币系统直接使用公钥作为比特币地址（P2PK，pay-to-pubkey）。由于后来证实 ECDSA 算法存在安全隐患，可以通过公钥破解私钥，因此在 2010 年引入了一种新的交易类型 P2PKH（pay-to-pubkey-hash），即使用公钥的哈希值作为收款地址。

UTXO模型
UTXO 与传统账户余额模型对比
建模对象：UTXO 模型对资产进行建模，用户交易通过扣减分布在全网区块中与自己账户地址关联的未花费交易输出（UTXO）之和。余额模型则对账户进行建模，直接记录账户的余额。
适用场景：UTXO 模型不存在账户当前状态的概念，可以称其为无状态模型，因此难以基于 UTXO 模型构建如智能合约等数字货币领域外的复杂应用。余额模型直接拥有账户余额状态等数据，便于进行丰富的编程应用。
隐私性：UTXO 模型为用户提供了隐私优势。比特币用户可以将每个 UTXO 存储在不同的地址中分别处理，从而隐藏其持有的 UTXO 之间的联系。比特币的设计极大降低了生成新地址的难度。
而在传统余额模型中，生成新账户非常麻烦，甚至不可行，迫使用户将全部或大部分资金存放在一个账户中。观察者可以直接查询这个账户的交易流水来获取信息。

解决双花问题
关键词解释：UTXO、区块时间戳、6 次确认、分叉及最长链原则
UTXO：当一个用户接收比特币时，该金额被记录为未花费的交易输出（UTXO）并存储在区块链中。比特币系统记录每一笔未花费的交易输出。当一笔比特币交易被创建并广播到区块链网络后，接收到此交易信息的节点会对其进行验证，检查其是否存在于 UTXO 数据库中。如果交易输出已不存在于 UTXO 中，则验证失败。
区块时间戳：当一个用户将 1 个比特币同时转账给两人时，只有一笔交易会成功。矿工会选择记录优先接收到的或手续费更高的交易。当交易被矿工记录到区块后，根据区块时间戳的大小来判断，最先被记录（时间戳较小）的交易为有效，其他记录了相同 UTXO 的交易的区块将被网络拒绝（因为该 UTXO 已被花费）。
6 次确认：指在当前区块之后又有 5 个区块被计算出来并连接到区块链上，每一个区块都相当于对前一个区块的确认。区块链上每增加一个区块，就增大了前面区块被篡改的难度。通常认为，在 6 个区块确认之后，交易基本上无法被篡改，因此被认为是最终完成的交易。
分叉及最长链原则：在同一时间段内，全网可能有多个节点同时计算出正确的随机数，即同时挖到矿。这些节点会将自己挖到的区块添加到本地区块链上，导致区块链分叉。矿工会在网络中广播自己打包好的区块，以便其他节点同步最新数据，并在最新的区块链上继续挖矿。由于同步需要时间，不同矿工看到这些区块的顺序会有所不同。矿工会复制先看到的区块，并在其基础上继续挖矿。最终，最长的链条会被确认为主链，其他分支链条上的节点将转换阵营，开始在较长的链条上工作，其他分叉出来的链将被网络抛弃。

相邻接点管理
当一个比特币节点启动时，它需要发现比特币网络中的其他节点，并至少与一个节点相连才能正常使用。节点通过 8333 端口与一个已知节点建立 TCP 连接。发现新节点有两种方法：
通过 DNS 种子：DNS 种子是提供比特币节点地址的 DNS 服务器。在 Bitcoin Core 软件配置中，自带了 5 个不同的 DNS 种子。
添加已知节点的 IP：用户可以通过配置文件或控制台命令的方式，手动添加已知节点的 IP 地址。

隔离见证
基本概念：SegWit 是目前比特币应对扩容较好的解决方案，主要思想是将区块中的签名信息隔离出来，实现变相扩容。
Witness（见证）在密码学中指的是签名，它可以证明事物的真实性。而在比特币中，witness 指的是交易输入中的解锁脚本（scriptSig），因为解锁脚本中包含签名信息，用以证明交易发起人可以使用对应的 UTXO。Segregated（隔离）指的是将解锁脚本从交易输入中分离出来，放在一个单独的数据结构中。矿工在打包交易时会验证这个新数据结构的有效性，以确保交易的合法性。
隔离见证如何解决区块扩容

一笔交易的平均大小是 250 字节，而解锁脚本就占用了一半的空间。通过将解锁脚本从交易中分离出来，区块可以容纳更多的交易笔数，从而间接达到区块扩容 2 倍的效果。

11.1.3 带来的好处
解决交易延展性问题： 计算交易 ID 时不再包括解锁脚本内容，使交易 ID 成为固定值，避免了交易 ID 被篡改的风险。
扩容： 以前解锁脚本内容最长会占据超过交易数据 75% 的空间，严重压缩了区块可容纳的交易数量。现在分离出去后，相当于变相扩容了区块，增加了比特币的交易吞吐量。
增加脚本版本管理： 引入隔离见证后，新的脚本结构中增加了版本号字段，类似于交易和区块，脚本也有了自己的版本号，使得脚本语言可以以一种向后兼容的方式进行升级。
优化签名算法： 隔离见证降低了签名函数（CHECKSIG/CHECKMULTSIG）算法的计算复杂性。例如，一笔交易中可能有多笔输入，验证过程中需要多次验证签名，而验签需要多次执行哈希计算。随着交易输入的增加，验证交易所需时间几乎呈指数增长。引入隔离见证后，所需时间呈线性增长，大大提高了效率。
节省 SPV 节点空间： 由于 SPV 节点不需要验证交易的有效性，只需验证交易的存在性即可。因此，SPV 节点不需要交易中的解锁脚本。去除这部分信息后，SPV 节点可以在同样的带宽下下载更多交易数据，节省了空间。
减少交易手续费： 解锁脚本被单独存放后，交易数据进行了「瘦身」，交易费与交易大小挂钩，交易数据变小了，自然手续费也就降低了。

以太坊简介 后续记一些笔记 目前没有发现要记得


















